// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_List from "rescript/lib/es6/belt_List.js";

function $$eval(expr) {
  var compile = function (_expr, _env) {
    while(true) {
      var env = _env;
      var expr = _expr;
      switch (expr.TAG | 0) {
        case /* Add */0 :
            return compile(expr._0, env) + compile(expr._1, env) | 0;
        case /* Mul */1 :
            return Math.imul(compile(expr._0, env), compile(expr._1, env));
        case /* Cst */2 :
            return expr._0;
        case /* Var */3 :
            return List.assoc(expr._0, env);
        case /* Let */4 :
            _env = {
              hd: [
                expr._0,
                compile(expr._1, env)
              ],
              tl: env
            };
            _expr = expr._2;
            continue ;
        
      }
    };
  };
  return compile(expr, /* [] */0);
}

function tostring(expr) {
  switch (expr.TAG | 0) {
    case /* Add */0 :
        var s1 = tostring(expr._0);
        var s2 = tostring(expr._1);
        return "Add(" + s1 + ", " + s2 + ")";
    case /* Mul */1 :
        var s1$1 = tostring(expr._0);
        var s2$1 = tostring(expr._1);
        return "Mul(" + s1$1 + ", " + s2$1 + ")";
    case /* Cst */2 :
        return "Cst(" + expr._0 + ")";
    case /* Var */3 :
        return "Var(\"" + expr._0 + "\")";
    case /* Let */4 :
        var s1$2 = tostring(expr._1);
        var s2$2 = tostring(expr._2);
        return "Let(\"" + expr._0 + "\", " + s1$2 + ", " + s2$2 + ")";
    
  }
}

var Ir0 = {
  $$eval: $$eval,
  tostring: tostring
};

function $$eval$1(expr) {
  var compile = function (_expr, _env) {
    while(true) {
      var env = _env;
      var expr = _expr;
      switch (expr.TAG | 0) {
        case /* Add */0 :
            return compile(expr._0, env) + compile(expr._1, env) | 0;
        case /* Mul */1 :
            return Math.imul(compile(expr._0, env), compile(expr._1, env));
        case /* Cst */2 :
            return expr._0;
        case /* Var */3 :
            return List.nth(env, expr._0);
        case /* Let */4 :
            _env = {
              hd: compile(expr._0, env),
              tl: env
            };
            _expr = expr._1;
            continue ;
        
      }
    };
  };
  return compile(expr, /* [] */0);
}

function tostring$1(expr) {
  switch (expr.TAG | 0) {
    case /* Add */0 :
        var s1 = tostring$1(expr._0);
        var s2 = tostring$1(expr._1);
        return "Add(" + s1 + ", " + s2 + ")";
    case /* Mul */1 :
        var s1$1 = tostring$1(expr._0);
        var s2$1 = tostring$1(expr._1);
        return "Mul(" + s1$1 + ", " + s2$1 + ")";
    case /* Cst */2 :
        return "Cst(" + expr._0 + ")";
    case /* Var */3 :
        return "Var(" + expr._0 + ")";
    case /* Let */4 :
        var s1$2 = tostring$1(expr._0);
        var s2$2 = tostring$1(expr._1);
        return "Let(" + s1$2 + ", " + s2$2 + ")";
    
  }
}

var Ir1 = {
  $$eval: $$eval$1,
  tostring: tostring$1
};

function index(l, x, n) {
  if (l) {
    var rest = l.tl;
    var hd = l.hd;
    if (n !== 0) {
      if (Caml_obj.equal(hd, x)) {
        return 1 + index(rest, x, n - 1 | 0) | 0;
      } else {
        return 1 + index(rest, x, n) | 0;
      }
    } else if (Caml_obj.equal(hd, x)) {
      return 0;
    } else {
      return 1 + index(rest, x, 0) | 0;
    }
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Lab.res",
          126,
          9
        ],
        Error: new Error()
      };
}

function convert(expr) {
  var compile = function (expr, env) {
    switch (expr.TAG | 0) {
      case /* Add */0 :
          return {
                  TAG: /* Add */0,
                  _0: compile(expr._0, env),
                  _1: compile(expr._1, env)
                };
      case /* Mul */1 :
          return {
                  TAG: /* Mul */1,
                  _0: compile(expr._0, env),
                  _1: compile(expr._1, env)
                };
      case /* Cst */2 :
          return {
                  TAG: /* Cst */2,
                  _0: expr._0
                };
      case /* Var */3 :
          return {
                  TAG: /* Var */3,
                  _0: index(env, expr._0, 0)
                };
      case /* Let */4 :
          return {
                  TAG: /* Let */4,
                  _0: compile(expr._1, env),
                  _1: compile(expr._2, {
                        hd: expr._0,
                        tl: env
                      })
                };
      
    }
  };
  return compile(expr, /* [] */0);
}

var Interpreter0 = {
  convert: convert
};

function get(index, stack) {
  return List.nth(stack, index);
}

var pop = Belt_List.tailExn;

function $$eval$2(instrs) {
  var _instrs = instrs;
  var _stack = /* [] */0;
  while(true) {
    var stack = _stack;
    var instrs$1 = _instrs;
    if (instrs$1) {
      var i = instrs$1.hd;
      if (typeof i === "number") {
        switch (i) {
          case /* Add */0 :
              if (stack) {
                var match = stack.tl;
                if (match) {
                  _stack = {
                    hd: stack.hd + match.hd | 0,
                    tl: match.tl
                  };
                  _instrs = instrs$1.tl;
                  continue ;
                }
                
              }
              break;
          case /* Mul */1 :
              if (stack) {
                var match$1 = stack.tl;
                if (match$1) {
                  _stack = {
                    hd: Math.imul(stack.hd, match$1.hd),
                    tl: match$1.tl
                  };
                  _instrs = instrs$1.tl;
                  continue ;
                }
                
              }
              break;
          case /* Pop */2 :
              _stack = Belt_List.tailExn(stack);
              _instrs = instrs$1.tl;
              continue ;
          case /* Swap */3 :
              if (stack) {
                var match$2 = stack.tl;
                if (match$2) {
                  _stack = {
                    hd: match$2.hd,
                    tl: {
                      hd: stack.hd,
                      tl: match$2.tl
                    }
                  };
                  _instrs = instrs$1.tl;
                  continue ;
                }
                
              }
              break;
          
        }
      } else {
        if (i.TAG === /* Cst */0) {
          _stack = {
            hd: i._0,
            tl: stack
          };
          _instrs = instrs$1.tl;
          continue ;
        }
        _stack = {
          hd: List.nth(stack, i._0),
          tl: stack
        };
        _instrs = instrs$1.tl;
        continue ;
      }
    } else if (stack) {
      return stack.hd;
    }
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lab.res",
            189,
            13
          ],
          Error: new Error()
        };
  };
}

function tostring$2(instrs) {
  if (!instrs) {
    return "";
  }
  var i = instrs.hd;
  if (typeof i !== "number") {
    if (i.TAG === /* Cst */0) {
      return "Cst(" + i._0 + ");" + tostring$2(instrs.tl);
    } else {
      return "Var(" + i._0 + ");" + tostring$2(instrs.tl);
    }
  }
  switch (i) {
    case /* Add */0 :
        return "Add;" + tostring$2(instrs.tl);
    case /* Mul */1 :
        return "Mul;" + tostring$2(instrs.tl);
    case /* Pop */2 :
        return "Pop;" + tostring$2(instrs.tl);
    case /* Swap */3 :
        return "Swap;" + tostring$2(instrs.tl);
    
  }
}

var Instr1 = {
  get: get,
  pop: pop,
  $$eval: $$eval$2,
  tostring: tostring$2
};

function compileIr0(expr) {
  var toIr1 = convert(expr);
  var toInstrs1 = function (expr, cenv) {
    switch (expr.TAG | 0) {
      case /* Add */0 :
          var target1 = toInstrs1(expr._0, cenv);
          var target2 = toInstrs1(expr._1, {
                hd: /* Temp */0,
                tl: cenv
              });
          return Belt_List.concatMany([
                      target1,
                      target2,
                      {
                        hd: /* Add */0,
                        tl: /* [] */0
                      }
                    ]);
      case /* Mul */1 :
          var target1$1 = toInstrs1(expr._0, cenv);
          var target2$1 = toInstrs1(expr._1, {
                hd: /* Temp */0,
                tl: cenv
              });
          return Belt_List.concatMany([
                      target1$1,
                      target2$1,
                      {
                        hd: /* Mul */1,
                        tl: /* [] */0
                      }
                    ]);
      case /* Cst */2 :
          return {
                  hd: {
                    TAG: /* Cst */0,
                    _0: expr._0
                  },
                  tl: /* [] */0
                };
      case /* Var */3 :
          return {
                  hd: {
                    TAG: /* Var */1,
                    _0: index(cenv, /* Local */1, expr._0)
                  },
                  tl: /* [] */0
                };
      case /* Let */4 :
          var target1$2 = toInstrs1(expr._0, cenv);
          var target2$2 = toInstrs1(expr._1, {
                hd: /* Local */1,
                tl: cenv
              });
          return Belt_List.concatMany([
                      target1$2,
                      target2$2,
                      {
                        hd: /* Swap */3,
                        tl: {
                          hd: /* Pop */2,
                          tl: /* [] */0
                        }
                      }
                    ]);
      
    }
  };
  return toInstrs1(toIr1, /* [] */0);
}

var Compiler = {
  compileIr0: compileIr0
};

var ir0 = {
  TAG: /* Let */4,
  _0: "x",
  _1: {
    TAG: /* Cst */2,
    _0: 1
  },
  _2: {
    TAG: /* Add */0,
    _0: {
      TAG: /* Var */3,
      _0: "x"
    },
    _1: {
      TAG: /* Var */3,
      _0: "x"
    }
  }
};

var ir1 = {
  TAG: /* Let */4,
  _0: {
    TAG: /* Cst */2,
    _0: 1
  },
  _1: {
    TAG: /* Add */0,
    _0: {
      TAG: /* Var */3,
      _0: 0
    },
    _1: {
      TAG: /* Var */3,
      _0: 0
    }
  }
};

var instrs1 = {
  hd: {
    TAG: /* Cst */0,
    _0: 1
  },
  tl: {
    hd: {
      TAG: /* Var */1,
      _0: 0
    },
    tl: {
      hd: {
        TAG: /* Var */1,
        _0: 1
      },
      tl: {
        hd: /* Add */0,
        tl: {
          hd: /* Swap */3,
          tl: {
            hd: /* Pop */2,
            tl: /* [] */0
          }
        }
      }
    }
  }
};

var ir1_str = tostring$1(ir1);

var instrs1_str = tostring$2(instrs1);

var ir0_result = $$eval(ir0);

var ir1_result = $$eval$1(ir1);

var Exple1 = {
  ir0: ir0,
  ir1: ir1,
  instrs1: instrs1,
  ir1_str: ir1_str,
  instrs1_str: instrs1_str,
  ir0_result: ir0_result,
  ir1_result: ir1_result
};

var ir0$1 = {
  TAG: /* Add */0,
  _0: {
    TAG: /* Cst */2,
    _0: 1
  },
  _1: {
    TAG: /* Let */4,
    _0: "x",
    _1: {
      TAG: /* Cst */2,
      _0: 2
    },
    _2: {
      TAG: /* Add */0,
      _0: {
        TAG: /* Var */3,
        _0: "x"
      },
      _1: {
        TAG: /* Cst */2,
        _0: 7
      }
    }
  }
};

var ir1$1 = {
  TAG: /* Add */0,
  _0: {
    TAG: /* Cst */2,
    _0: 1
  },
  _1: {
    TAG: /* Let */4,
    _0: {
      TAG: /* Cst */2,
      _0: 2
    },
    _1: {
      TAG: /* Add */0,
      _0: {
        TAG: /* Var */3,
        _0: 0
      },
      _1: {
        TAG: /* Cst */2,
        _0: 7
      }
    }
  }
};

var instrs1$1 = {
  hd: {
    TAG: /* Cst */0,
    _0: 1
  },
  tl: {
    hd: {
      TAG: /* Cst */0,
      _0: 2
    },
    tl: {
      hd: {
        TAG: /* Var */1,
        _0: 0
      },
      tl: {
        hd: {
          TAG: /* Cst */0,
          _0: 7
        },
        tl: {
          hd: /* Add */0,
          tl: {
            hd: /* Swap */3,
            tl: {
              hd: /* Pop */2,
              tl: {
                hd: /* Add */0,
                tl: /* [] */0
              }
            }
          }
        }
      }
    }
  }
};

var ir1_str$1 = tostring$1(ir1$1);

var instrs1_str$1 = tostring$2(instrs1$1);

var ir0_result$1 = $$eval(ir0$1);

var ir1_result$1 = $$eval$1(ir1$1);

var Exple2 = {
  ir0: ir0$1,
  ir1: ir1$1,
  instrs1: instrs1$1,
  ir1_str: ir1_str$1,
  instrs1_str: instrs1_str$1,
  ir0_result: ir0_result$1,
  ir1_result: ir1_result$1
};

function check_interpreter(param) {
  var ir0_to_ir1 = convert(ir0);
  if (ir1_str !== tostring$1(ir0_to_ir1)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lab.res",
            281,
            6
          ],
          Error: new Error()
        };
  }
  if (ir1_result !== $$eval$1(ir0_to_ir1)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lab.res",
            282,
            6
          ],
          Error: new Error()
        };
  }
  var ir0_to_ir1$1 = convert(ir0$1);
  if (ir1_str$1 !== tostring$1(ir0_to_ir1$1)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lab.res",
            287,
            6
          ],
          Error: new Error()
        };
  }
  if (ir1_result$1 !== $$eval$1(ir0_to_ir1$1)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lab.res",
            288,
            6
          ],
          Error: new Error()
        };
  }
  console.log("test_interpreter0() is successful!");
}

function check_compiler(param) {
  var instrs1 = compileIr0(ir0);
  if ($$eval$2(instrs1) !== ir0_result) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lab.res",
            301,
            6
          ],
          Error: new Error()
        };
  }
  if (tostring$2(instrs1) !== instrs1_str) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lab.res",
            302,
            6
          ],
          Error: new Error()
        };
  }
  var instrs1$1 = compileIr0(ir0$1);
  if ($$eval$2(instrs1$1) !== ir0_result$1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lab.res",
            307,
            6
          ],
          Error: new Error()
        };
  }
  if (tostring$2(instrs1$1) !== instrs1_str$1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Lab.res",
            308,
            6
          ],
          Error: new Error()
        };
  }
  console.log("test_compileIr0() is successful!");
}

function test(param) {
  check_interpreter(undefined);
  check_compiler(undefined);
}

var Test = {
  Exple1: Exple1,
  Exple2: Exple2,
  check_interpreter: check_interpreter,
  check_compiler: check_compiler,
  test: test
};

check_interpreter(undefined);

check_compiler(undefined);

export {
  Ir0 ,
  Ir1 ,
  index ,
  Interpreter0 ,
  Instr1 ,
  Compiler ,
  Test ,
}
/* ir1_str Not a pure module */
